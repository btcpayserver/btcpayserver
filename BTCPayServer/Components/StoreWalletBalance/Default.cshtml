@using BTCPayServer.Services.Wallets
@model BTCPayServer.Components.StoreWalletBalance.StoreWalletBalanceViewModel

@{
    var storeBlob = Model.Store.GetStoreBlob();
}
<style>
    #DefaultCurrencyToggle .btn {
        background-color: var(--btcpay-bg-tile);
        border-color: var(--btcpay-body-border-light);
    }
    
    #DefaultCurrencyToggle input:not(:checked) + .btn {
        color: var(--btcpay-body-text-muted);
    }
</style>
<div id="StoreWalletBalance-@Model.Store.Id" class="widget store-wallet-balance">
    <div class="d-flex gap-3 align-items-center justify-content-between mb-2">
        <h6>Wallet Balance</h6>
        @if (Model.CryptoCode != storeBlob.DefaultCurrency)
        {
            <div class="btn-group btn-group-sm gap-0" role="group" id="DefaultCurrencyToggle">
                <input type="radio" class="btn-check" name="currency" id="currency_@Model.CryptoCode" value="@Model.CryptoCode" autocomplete="off" checked>
                <label class="btn btn-outline-secondary px-2 py-1" for="currency_@Model.CryptoCode">@Model.CryptoCode</label>
                <input type="radio" class="btn-check" name="currency" id="currency_@storeBlob.DefaultCurrency" value="@storeBlob.DefaultCurrency" autocomplete="off">
                <label class="btn btn-outline-secondary px-2 py-1" for="currency_@storeBlob.DefaultCurrency">@storeBlob.DefaultCurrency</label>
            </div>
        }
    </div>
    <header class="mb-3">
        @if (Model.Balance is not null)
        {
            <div class="balance" id="balance-@Model.CryptoCode">
                <h3 class="d-inline-block me-1">@Model.Balance</h3>
                <span class="text-secondary fw-semibold">@Model.CryptoCode</span>
            </div>
            <div class="balance" id="balance-@storeBlob.DefaultCurrency">
                <h3 class="d-inline-block" id="DefaultCurrencyBalance"></h3>
                <span class="text-secondary fw-semibold">@storeBlob.DefaultCurrency</span>
            </div>
        }
        <div class="btn-group mt-1" role="group" aria-label="Filter">
            <input type="radio" class="btn-check" name="filter" id="filter-week" value="week" @(Model.Type == WalletHistogramType.Week ? "checked" : "")>
            <label class="btn btn-link" for="filter-week">1W</label>
            <input type="radio" class="btn-check" name="filter" id="filter-month" value="month" @(Model.Type == WalletHistogramType.Month ? "checked" : "")>
            <label class="btn btn-link" for="filter-month">1M</label>
            <input type="radio" class="btn-check" name="filter" id="filter-year" value="year" @(Model.Type == WalletHistogramType.Year ? "checked" : "")>
            <label class="btn btn-link" for="filter-year">1Y</label>
        </div>
    </header>
    <div class="ct-chart"></div>
    <script>
        (function () {
            const defaultCurrency = @Safe.Json(storeBlob.DefaultCurrency);
            const cryptoBalance = document.getElementById("balance-@Model.CryptoCode");
            const defaultBalance = document.getElementById("balance-@storeBlob.DefaultCurrency");
            
            document.getElementById("balance-@storeBlob.DefaultCurrency").style.display = 'none';
            const id = 'StoreWalletBalance-@Model.Store.Id';
            const baseUrl = @Safe.Json(Url.Action("WalletHistogram", "UIWallets", new { walletId = Model.WalletId, type = WalletHistogramType.Week }));
            const chartOpts = {
                fullWidth: true,
                showArea: true,
                axisY: {
                    labelInterpolationFnc: value => rate
                        ? displayDefaultCurrency(value, defaultCurrency).toString()
                        : value
                }
              }
            const render = data => {
                const { series, labels, balance } = data;
                if (balance)
                    document.querySelector(`#${id} h3`).innerText = balance;
                const min = Math.min(...series);
                const max = Math.max(...series);
                const low = Math.max(min - ((max - min) / 5), 0);
                const renderOpts = Object.assign({}, chartOpts, { low });
                const chart = new Chartist.Line(`#${id} .ct-chart`, {
                    labels,
                    series: [series]
                }, renderOpts);
                // prevent y-axis labels from getting cut off
                window.setTimeout(() => {
                    const yLabels = [...document.querySelectorAll('.ct-label.ct-vertical.ct-start')];
                    if (yLabels) {
                        const factor = rate ? 6 : 8;
                        const width = Math.max(...(yLabels.map(l => l.innerText.length * 8)));
                        const opts = Object.assign({}, renderOpts, { 
                            axisY: Object.assign({}, renderOpts.axisY, { offset: width })
                        });
                        chart.update(null, opts);
                    }
                }, 0)
            };
            const update = async type => {
                const url = baseUrl.replace(/\/week$/gi, `/${type}`);
                const response = await fetch(url);
                if (response.ok) {
                  const json = await response.json();
                  render(json);
                }
            };
            render({ series: @Safe.Json(Model.Series), labels: @Safe.Json(Model.Labels), balance: @Safe.Json(Model.Balance) });
            document.addEventListener('DOMContentLoaded', () => {
                delegate('change', `#${id} [name="filter"]`, async e => {
                    const type = e.target.value;
                    await update(type);
                })
                delegate('change', '#DefaultCurrencyToggle input', async e => {
                    const { target } = e;
                    let rate = null;
                    if (target.value === defaultCurrency) {
                        const currencyPair = @Safe.Json($"{Model.CryptoCode}_{storeBlob.DefaultCurrency}");
                        const response = await fetch(`@Context.Request.PathBase/api/rates?storeId=@Model.Store.Id&currencyPairs=${currencyPair}`);
                        const json = await response.json();
                        rate = json[0] && json[0].rate;
                        if (rate) {
                            const balance = (Math.round((rate * @Model.Balance) * 100) / 100).toString();
                            document.getElementById('DefaultCurrencyBalance').innerText = new Intl.NumberFormat(navigator.language, { style: 'decimal', currency: defaultCurrency }).format(balance);
                        } else {
                            console.warn(`Fetching rate for ${currencyPair} failed.`);
                        }
                    }
                    cryptoBalance.style.display = rate ? 'none' : 'block';
                    defaultBalance.style.display = rate ? 'block' : 'none';
                });
            });
        })();
    </script>
</div>
